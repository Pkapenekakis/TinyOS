#include <stdio.h>
#include "micropulse.h"

module MicroPulseC {
    uses interface Random;
    uses interface Packet as PacketP1; 
    uses interface AMPacket as AMPacketP1;
    uses interface Packet as PacketP2; 
    uses interface AMPacket as AMPacketP2;
    uses interface AMSend as AMSendP1; // For Phase 1
    uses interface AMSend as AMSendP2; // For Phase 2
    uses interface Receive as ReceiveP1; // For Phase 1
    uses interface Receive as ReceiveP2; // For Phase 2
    provides interface MicroPulse;
}

implementation {
    uint16_t childMaxValue; //critical Path
    uint16_t upperBound; //UpperBound of timing window
    uint16_t load;
    uint16_t taskParentID;
    message_t output; //Needs to be declared here in order for the sendData task to work
    bool sendBusy = FALSE; //Flag to track if we are seding data at the moment
    bool alreadySentData = FALSE;
    static uint8_t retryCount = 0;
    static uint8_t MAX_RETRIES = 20;


    /********************************************************************
    Generating Loads Functions
    ********************************************************************/

    //Reads a Random Number from the file seed.txt that is generated by the python Script
    //Is used to seed the random Number generation.
    uint32_t readSeedFromFile() {
        uint32_t seed = 0;
        FILE* file = fopen("seed.txt", "r");
        if (file != NULL) {
            fscanf(file, "%u", &seed);
            fclose(file);
        }else{
            dbg("CustomAggregationFunction", "Failed to read seed.txt, using default seed (1). \n");
            seed = 1;  // Default seed
        }
        return seed;
    }

    //Generates a random load between 20 and 60 inclusive
    command void MicroPulse.generateLoad(){
        uint32_t seed = readSeedFromFile();

        load = 20 + (call Random.rand16() + seed ) % 41;
        dbg("generateValues", "Node: %d had load generated: %d \n",TOS_NODE_ID, load);
    }


    /********************************************************************
    Send Functions for Phase 1
    ********************************************************************/

    //Sends a message to parent about the criticalPath
    task void sendCriticalPathToParentTask() {
        static error_t sendError;
        micropulse_t* payload;

        if(sendBusy){
            dbg("Phase1CriticalPathTask", "Send already in progress for node %d\n", TOS_NODE_ID);
            return;
        }

        sendBusy = TRUE; //A send is starting

        // Prepare the message
        //payload = (micropulse_t*) output.data;
        payload = (micropulse_t*) call PacketP1.getPayload(&output, sizeof(micropulse_t));

        if (payload == NULL) {
            dbg("Phase1CriticalPathTask", "Node %d: Failed to get payload!\n", TOS_NODE_ID);
            sendBusy = FALSE;
            post sendCriticalPathToParentTask();  // Retry
            return;
        }

        atomic {
            payload->criticalValue = childMaxValue + load;
        }

        dbg("Phase1CriticalPathTask", "Sending CriticalPath to: %d\n", childMaxValue + load);

        call AMPacketP1.setDestination(&output, taskParentID);
        call PacketP1.setPayloadLength(&output, sizeof(micropulse_t));
       
        sendError = call AMSendP1.send(taskParentID, &output, sizeof(micropulse_t));

        if (sendError != SUCCESS) {
            dbg("Phase1CriticalPathTask", "Node %d: Send failed, reposting task\n", TOS_NODE_ID);
            sendBusy = FALSE; // Reset flag
            post sendCriticalPathToParentTask();  // Retry
        }
    }

    //Propagate Critical Path to Parent (Phase 1)
    command void MicroPulse.propagateCriticalPathToParent(uint16_t parentID) {
        taskParentID = parentID;

        post sendCriticalPathToParentTask();
    }


    event void AMSendP1.sendDone(message_t* msg, error_t err) {
        sendBusy = FALSE; //Reset the flag since message sent
        if (err == SUCCESS) {
            dbg("Phase1CriticalPathTask", "Node %d: Message sent successfully to parent!\n", TOS_NODE_ID);
        } else {
            dbg("Phase1CriticalPathTask", "Node %d:  Message send failed in sendDone, reposting task\n", TOS_NODE_ID);
            post sendCriticalPathToParentTask();  //Retry on failure
        }
    }

    /********************************************************************
    Receive Functions for Phase 1
    ********************************************************************/

    //Receive data from father nodes
    event message_t* ReceiveP1.receive(message_t* msg, void* payload, uint8_t len) {
        //micropulse_t receivedData = *(micropulse_t*)payload;
        micropulse_t* receivedData = (micropulse_t*) payload;
        uint16_t receivedMax;

        if (payload == NULL) {
            dbg("Phase1Receive", "Received null payload\n");
            return msg;
        }

        receivedMax = receivedData->criticalValue;

        dbg("Phase1Receive", "Node %d: Received data: critPath: %d \n",TOS_NODE_ID, receivedMax );

        if(childMaxValue < receivedMax){
            childMaxValue = receivedMax;
        }
   

        return msg;
    }

    /********************************************************************
    Send Functions for Phase 2
    ********************************************************************/

    //Sends a message to children about the criticalPath -- IS PHASE 2
    task void sendCriticalPathTask() {
        static error_t sendError;
        micropulse_t* payload;

        if(alreadySentData){
            return;
        }

        //dbg("Custom","Node: %d Crash check in send\n",TOS_NODE_ID);

        if(output.data == NULL){
            return;
        }

        memset(&output, 0, sizeof(message_t));
        payload = (micropulse_t*) call PacketP2.getPayload(&output, sizeof(micropulse_t));

        

        if(sendBusy){
            dbg("Phase2PathPropagation", "Send already in progress for node %d\n", TOS_NODE_ID);
            return;
        }

        sendBusy = TRUE; //A send is starting

        if (payload == NULL) {
            dbg("Phase2PathPropagation", "Failed to get payload!\n");
            sendBusy = FALSE;
            if(retryCount > MAX_RETRIES){
                return;
            }
            retryCount++;
            post sendCriticalPathTask();  // Retry
            return;
        }

        atomic {
            payload->criticalValue = upperBound;
        }

        dbg("Phase2PathPropagation", "Node %d: Propagating critical value to children: %u\n",TOS_NODE_ID, upperBound);

        call AMPacketP2.setDestination(&output, AM_BROADCAST_ADDR);
        call PacketP2.setPayloadLength(&output, sizeof(micropulse_t));

        sendError = call AMSendP2.send(AM_BROADCAST_ADDR, &output, sizeof(micropulse_t));

        if (sendError != SUCCESS) {
            dbg("Phase2PathPropagation", "Send failed, reposting task\n");
            sendBusy = FALSE;
            if(retryCount > MAX_RETRIES){
                return;
            }
            retryCount++;
            post sendCriticalPathTask();  // Retry
        }
    }

    event void AMSendP2.sendDone(message_t* msg, error_t err) {
        sendBusy = FALSE; //Reset the flag since message sent
        if (err == SUCCESS) {
            alreadySentData = TRUE;    
            dbg("Phase2PathPropagation", "Critical Path sent successfully!\n");
        } else {
            dbg("Phase2PathPropagation", "Message send failed in sendDone, reposting task\n");
            if(retryCount > MAX_RETRIES){
                return;
            }
            retryCount++;
            post sendCriticalPathTask();  //Retry on failure
        }
    }

    /********************************************************************
    Receive Functions for Phase 2
    ********************************************************************/

    //Receive data from father nodes
    event message_t* ReceiveP2.receive(message_t* msg, void* payload, uint8_t len) {
        micropulse_t receivedData;
        uint16_t senderID;

        if (msg == NULL) {
            dbg("Phase2Receive", "Received null message\n");
            return msg;
        }

        if (payload == NULL) {
            dbg("Phase2Receive", "Received null payload\n");
            return msg;
        }
        
        senderID = call AMPacketP2.source(msg);
        receivedData = *(micropulse_t*) payload;

        //dbg("Custom","SENDER ID FOR NODE: %d is node: %d and PARENTID IS %d\n",TOS_NODE_ID, senderID, taskParentID);

        
        if(taskParentID != senderID){ 
            //dbg("CustomBug", "Node: %d Received message from Non-Parent %d\n",TOS_NODE_ID, senderID);
            return msg;
        }

        upperBound = receivedData.criticalValue - load;

        if(upperBound < 0){
            upperBound = 0;
        }

        dbg("Phase2Receive","Node: %d collected criticalPath Value: %d\n", TOS_NODE_ID, upperBound);

        post sendCriticalPathTask();
     
        return msg;
    }

    /********************************************************************
    Experimental Solution
    ********************************************************************/

    //Only called by Node 0
    command void MicroPulse.finalizePhaseOne(){
        dbg("Phase2Receive", "\n Node: %d changes phase \n", TOS_NODE_ID);
        upperBound = childMaxValue; //For node 0 the value it receives from children is its upperbound
        post sendCriticalPathTask();
    }

    command uint16_t MicroPulse.getCriticalPathValue(){
        return childMaxValue;
    }

    command uint16_t MicroPulse.getLoadValue(){
        return load;
    }

    command uint16_t MicroPulse.getUpperBound(){
        return upperBound;    
    }

   























}
